Hummer Ultra Sound for NeoGS. Алгоритм работы FPGA.

Не факт, что нежелезячникам будет интересно, но все же.

Железо, относящееся к аудиочипу, состоит из нескольких модулей:
- управляющей FSM,
- фетчера из SRAM,
- интерполятора,
- FIFO звуковых выборок,
- сериализатора аудио ЦАП-а.

Есть две таблицы, хранящиеся во внутренней памяти FPGA.
Первая - та самая с параметрами каналов. Процессор ее может писать, FPGA - только читать.
Вторая - таблица состояний каналов. К ней доступ имеет только FPGA на чтение и запись.
Она содержит:
- текущий адрес,
- текущий суб-адрес, который используется для работы с дробной частью шага,
- текущую и предыдущую выборки сэмпла,
- флаги: активность, текущее направление движения по сэмплу, необходимость запроса памяти в следующей итерации.

Для того, чтобы сгенерировать две выборки аудио ЦАП-а по 16 бит, FSM проходит по обеим таблицам, делая процессинг каждого канала.
В конце обработки канала выход интерполятора прибавляется к сумматору звука.
После обработки всех каналов значение из сумматора умножается на выходную громкость и запихивается в FIFO.

Обработка каждого канала состоит из нескольких шагов FSM.
В каждом шаге возможно ветвление на несколько сценариев.

Самый простой: канал неактивен.
Неактивность определяется режимом канала (при перезапуске) или состоянием проигрывания (если сэмпл доиграл до конца, а loop не включен).
В этом случае тратится только 1 такт и происходит переход на следующий элемент таблицы.

Если канал активен, возможно несколько сценариев.

Если установлен флаг перезапуска:
- берется начальный адрес памяти,
- запускаются фетчер и интерполятор,
- происходит переход на вычисление нового адреса.

Если перезапуска не было, то проверяется требование запроса памяти.
Если запрос не нужен, берется старая выборка, но интерполятор запускается с новым значением указателя.
Если был запрос, запускается фетчер.

На шаге вычисления нового адреса:
- складываются дробная часть инкремента и суб-адрес,
- если происходит переполнение суб-адреса, выставляется флаг запроса памяти в следующей итерации,
- прибавляется/вычитается целая часть инкремента с учетом формата сэмпла (1/2/4 байта на выборку),
- проверяется, достиг ли указатель конца/начала сэмпла и соответственно меняется состояние/направление проигрывания,
- в таблицу состояний сохраняются новый адрес и флаги.

Фетчер и интерполятор работают параллельно с FSM.
На шаге, когда FSM готова дать запрос фетчеру, проверяется, не занят ли он обработкой предыдущего запроса, и ожидается готовность.
Фетчер формирует запрос BUSRQ, ждет появление BUSAK, выставляет адрес для ОЗУ, принимает данные и передает их на обработку интерполятору, проверяя не занят ли тот с прошлого раза.

Таким образом, провисания всех зависимых модулей отсрочены на 1 итерацию вперед.
Нагрузка на доступ к ОЗУ уменьшена до необходимого предела.
Шаги FSM оптимизированы таким образом, чтоб не тратить ни одного лишнего такта.
